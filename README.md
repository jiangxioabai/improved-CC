# improved-CC
improved CC strategy for SAT

## algorithm

![alt text](image-2.png)

## general notation
- $L1(x_i),L2(x_i)$: 分别记录 $N(x_i)$ 中前一次和前两次翻转的变量。
- $N(F,x_i,s)$: $F$ 在赋值 $s$ 下翻转$x_i$的时候造成满足子句的差异.

## valuable pairs
![alt text](image.png)

## reversible variable
![alt text](image-1.png)

# improved-CC

improved CC strategy for SAT

## 算法概述

本算法在传统 CC（Configuration Checking）基础上改进引入了“e‑flippable”变量的概念，其核心在于结合了两类变量：

1. **q‑flippable 变量**  
   - 分为 1‑step 和 2‑step 两种：  
     - **1‑step q‑flippable**：仅依据自身局部配置变化（记录在 L1(x)）和得分变化（通过 N(F, x, s) 计算）判断。  
     - **2‑step q‑flippable**：同时考虑相邻变量（利用邻居关系 var_neighbor 以及记录最近两次翻转的 L1(x) 与 L2(x)）的影响，判断是否存在连续翻转能带来更优的局部配置。

2. **Reversible 变量**  
   - 当某次翻转产生了错误决策时，通过连续翻转相邻变量恢复较优状态。判断依据同样依赖于 L1(x)/L2(x) 以及相应得分 N(F, x, s) 的比较。

结合这两类变量，定义了 **e‑flippable 变量**，其集合正好为 q‑flippable 变量与 reversible 变量的并集，从而在局部搜索过程中既可以获得更优的局部配置，也可以纠正错误的翻转决策。






## 4.3.2 critical pairs
- $Cpair$: the list of critical pairs.
- $LCP(x_i)$: 包含 $x_i$ 的 $Cpair$ 子集.
- $LCC(x_i,x_j)$:  同时包含 $(x_i,x_j)$ 的子句，其中 $(x_i,x_j) \in Cpair$。
- LCQ: critical 且 flippable的pair集合
根据 $L1(x_i),L2(x_i),N(F,x_i,s),N(F,x_j,s)$ 再考虑 $x_i,x_j$ 同时出现的子句。

- LCR: critical 且 reversible的集合

目前的代码中，对于单元子句的检查仅限于计算文字数量，也就是说 $(x_1,x_1,x_1) \red{不会}$ 被视为单元子句，那么random-3 SAT不会有两个变量的子句

## 4.3.3 noncritical variables
- $U(x_i)$: 取 0/1 表示 $x_i$ 的邻居(包含 $x_i$ 本身)自从上一次算法执行line3 or 4之后有没有翻转过

- $LU$: $U(x_i)= 1$ 的集合

- 论文中的 $N(c)$ 其实就是原始代码中的sat_count[c]

- $LN$ : sat_count=1的non_critical子句集合

- $LN(x_i)$ : $LN$ 中包含 $x_i$ 的子句集合

- 𝑇 (𝐶) denotes the step at which 𝑄(𝐶), 𝑅(𝐶), 𝑆 (𝐶), 𝑃 (𝐶) are updated.

- $Q(C)$: 子句 $C$ 中是否包含q-flipapble pairs

- $R(C)$: 子句 $C$ 中是否包含reversible pairs

- $P(C)$: corresponding pair with highest score

- $S(C)$: corresponding score

## 3/17晚上
- qualified pairs (xi,xj) 的判断：首先对于每个变量记录一个改变队列
分几种情况xi
1. 如果xi改变队列里面的变量是相同的，那么就是q
2. 如果变量不同，而且
2.1  xi不在里面，那么就是q
2.2  xi，xj在里面 这时看xj的改变队列，如果也是xi,xj 非q

# improved-CC – 数据结构详细说明

本文档详细介绍了 improved-CC 项目中所使用的数据结构及其设计思想，这些数据结构在实现基于配置检查（Configuration Checking, CC）的局部搜索 SAT 算法中起到了关键作用。下面的说明将结合论文的理论描述和代码实现（主要见于 `basis.h`、`cca.cpp` 等文件），对各个数据结构进行详细阐述。

---

## 1. 基础数据结构

### 1.1 文字（Literal）数据结构

- **结构体 `lit`**  
  定义在 `basis.h` 中，用于描述 SAT 问题中的每个文字。  
  **字段说明：**
  - `clause_num`：所属子句的编号（从 0 开始）。
  - `var_num`：对应的变量编号（从 1 开始）。
  - `sense`：布尔值，1 表示正文字，0 表示负文字。

这个结构体是构建子句和变量列表的基本单元。

### 1.2 子句与变量的文字数组

- **变量文字数组 `var_lit` 及计数 `var_lit_count`**  
  - `var_lit[i]`：保存变量 *i* 出现的所有文字。  
  - `var_lit_count[i]`：记录变量 *i* 出现的文字个数。  
  该数组便于快速定位某个变量在整个公式中出现的位置和对应的文字信息。

- **子句文字数组 `clause_lit` 及计数 `clause_lit_count`**  
  - `clause_lit[c]`：保存子句 *c* 中的所有文字。  
  - `clause_lit_count[c]`：记录子句 *c* 中包含的文字个数。  
  在读取 DIMACS 格式实例时，通过扫描每个子句，将文字存入对应的 `clause_lit` 数组中。

- **原始子句文字数组 `org_clause_lit` 与计数 `org_clause_lit_count`**  
  用于在预处理（如单元子句消解）时保留原始子句信息，便于验证最终解时检查所有原始子句是否被满足。

---

## 2. 变量信息及辅助数组

### 2.1 变量状态与分数

- **当前解 `cur_soln`**  
  数组 `cur_soln[i]` 保存变量 *i* 在当前解中的布尔取值（1 表示 True，0 表示 False）。

- **变量得分 `score`**  
  数组 `score[i]` 表示翻转变量 *i* 对公式满足子句数的影响（通常为翻转后满足子句数与翻转前的差值），作为局部搜索中衡量变量重要性的指标。

- **时间戳 `time_stamp`**  
  数组 `time_stamp[i]` 记录变量 *i* 最近一次被翻转的步数，用于在得分相同的情况下优先选择翻转时间较早（即“老”变量）的变量。

- **配置检查标志 `conf_change`**  
  数组 `conf_change[i]` 用于标记变量 *i* 是否因其邻域内的变化而“配置发生了变化”，这是配置检查策略中的一个关键判断条件。

### 2.2 邻居信息

- **邻居数组 `var_neighbor` 及计数 `var_neighbor_count`**  
  - `var_neighbor[i]` 是一个整数数组，存储变量 *i* 的所有邻居变量编号。  
  - `var_neighbor_count[i]` 则记录了变量 *i* 的邻居数。  
  由函数 `build_neighbor_relation()` 构建，该函数遍历变量 *i* 出现的所有子句，并将同一子句中出现的其他变量标记为 *i* 的邻居。  
  此数据结构对于实现局部配置检查至关重要，因为判断变量翻转是否“新颖”依赖于检查其邻居的翻转历史。

### 2.3 配置检查辅助数据结构

- **记录邻域翻转历史的数组 \(L1(x_i)\) 与 \(L2(x_i)\)**  
  - `L1(x_i)`：记录变量 *x_i* 的邻域 \(N(x_i)\) 中最近一次被翻转的变量编号。  
  - `L2(x_i)`：记录 *x_i* 邻域中倒数第二次翻转的变量编号。  
  这两个数组用于判断变量 *x_i* 当前的局部配置是否与之前已经出现过的配置相同，从而实现对“qualified”或“eligible”状态的检测。  
  在变量翻转时，相关邻居的 \(L1\) 和 \(L2\) 值会以 \(O(\Delta)\)（其中 \(\Delta\) 为邻居数上界）的代价进行更新。

- **局部影响得分 \(N(F, x_i, s)\)**  
  该值表示在当前赋值 \(s\) 下，当变量 *x_i* 被翻转时，对满足子句数造成的变化（差分得分）。在局部搜索中，此得分可作为衡量翻转变量“价值”的近似指标，且更新代价较低。

---

## 3. 子句信息与 SAT 统计

### 3.1 子句权重与满足计数

- **子句权重 `clause_weight`**  
  数组 `clause_weight[c]` 存储子句 *c* 的当前权重，权重更新策略用于实现 aspiration（期望）机制，即当局部搜索陷入局部最优时，通过增加权重使某些子句更容易被关注。

- **满足计数 `sat_count` 与满足变量 `sat_var`**  
  - `sat_count[c]`：记录子句 *c* 在当前赋值下被满足的文字数量。  
  - `sat_var[c]`：记录若子句 *c* 仅有一个文字满足，则存储该文字对应的变量编号（若没有满足，则为 0）。  
  这些统计数据用于判断是否存在“单元子句”，以及在局部更新中快速计算变量翻转后子句满足情况的变化。

### 3.2 不满足子句与候选变量栈

- **不满足子句栈 `unsat_stack` 及其指针 `unsat_stack_fill_pointer`**  
  保存当前不满足的子句编号，用于在多样化阶段随机选择一个不满足的子句进行“聚焦随机游走”。

- **不满足变量栈 `unsatvar_stack` 及其指针 `unsatvar_stack_fill_pointer`**  
  记录出现在不满足子句中的变量编号，供贪婪模式下备选变量的扫描与选择。

- **配置改变的好变量栈 `goodvar_stack` 及指针 `goodvar_stack_fill_pointer`**  
  存储那些满足 1-step q-flippable 条件且 score > 0 的变量，优先用于局部搜索中的贪婪翻转选择。

---

## 4. 关键对（Critical Pairs）与非关键对

改进策略中，为了更精确地选择翻转变量，还引入了对“变量对”的检测，区分“关键对”与“非关键对”。

### 4.1 关键对相关数据结构

- **关键对列表 `CPair`**  
  枚举所有出现在同一子句中的变量对（对中变量编号按照一定顺序排列，如只记录 \(x_i, x_j\) 且 \(i < j\)），用于判断某个子句是否为“关键子句”（critical clause），即子句中至少有两个变量与其他子句共享。

- **子集 `LCP(x_i)` 与 `LCC(x_i, x_j)`**  
  - `LCP(x_i)`：关键对中包含变量 *x_i* 的子列表。  
  - `LCC(x_i, x_j)`：记录同时包含 \(x_i\) 与 \(x_j\) 的子句集合（仅对在 `CPair` 中的对）。
  
- **LCQ 与 LCR**  
  - **LCQ**：保存所有关键且满足 q-flippable 条件的变量对；  
  - **LCR**：保存所有关键且满足 reversible 条件的变量对。  
  这些列表在局部搜索中帮助快速定位对局部配置影响较大的变量对，便于选择优先翻转的候选变量。

### 4.2 非关键子句数据结构

- **非关键子句列表 `LN` 与变量关联列表 `LN(x_i)`**  
  - `LN`：记录满足条件（如 sat_count = 1）的非关键子句集合；  
  - `LN(x_i)`：存储非关键子句集合中包含变量 *x_i* 的子句，用于在更新时快速确定哪些子句受当前变量翻转的影响。

- **更新标记 `U(x_i)` 及列表 `LU`**  
  - `U(x_i)`：二值标记，表明自上一次执行贪婪选择（Line 3 或 4）后，变量 *x_i* 及其邻居是否有翻转。  
  - `LU`：收集所有 \(U(x_i)=1\) 的变量，便于局部更新时只针对受影响的部分进行检查和数据结构更新。

---

## 5. 针对非关键子句的局部数据结构更新（基于子句级）

为了高效支持在每次变量翻转后更新非关键子句的状态，项目中还维护了以下数据结构：

- **子句满足计数 `N(C)`**  
  对于每个子句 \(C\)，使用 `N(C)`（在代码中对应为 `sat_count[c]`）记录当前满足该子句的文字数量。更新操作在每次变量翻转时可在 \(O(\Delta)\) 时间内完成。

- **针对每个子句的辅助标记与时间戳**  
  当算法执行贪婪选择（例如 Line 3 或 Line 4）时，为非关键子句 \(C\) 维护以下元素：
  - `T(C)`：记录上一次更新的步数。
  - `Q(C)`：标记子句 \(C\) 中是否存在 u-q-flippable 的变量对。
  - `R(C)`：标记子句 \(C\) 中是否存在 reversible 的变量对（当不存在 u-q-flippable 对时）。
  - `P(C)`：记录对应的变量对（例如 u-q-flippable 或 reversible 对）中得分最高的那一对。
  - `S(C)`：记录对应变量对的得分。
  
  这些标记有助于在贪婪模式下迅速找出局部影响最大的变量对，从而确定翻转候选变量。

- **分组队列管理**  
  对于 LCQ、LCR 以及非关键子句列表 LN，项目通过将得分相同的变量对或子句归入同一子列表，并采用队列的方式管理，保证在更新时能够以 \(O(1)\) 的时间复杂度选取最高分的候选。

---

## 6. 动态数据结构的维护成本

- **变量级更新**：  
  由于每个变量的邻居数上限为 \(\Delta\)，如 \(L1(x_i)\)、\(L2(x_i)\) 及分数 `N(F, x_i, s)` 等数据结构的更新均在 \(O(\Delta)\) 内完成。

- **子句级更新**：  
  对于每个翻转操作，只需更新包含该变量的子句（个数也在 \(O(\Delta)\) 内），并对受影响的非关键子句列表 LN 和辅助标记进行局部更新。贪婪选择阶段更新涉及的总体摊还代价为 \(O(\Delta^2)\)，但实际中由于局部受影响变量数量较少，此代价十分低。

- **关键对及队列管理**：  
  由于在随机 3-SAT 实例中，关键子句的期望数量较小（论文中证明关键子句期望数不超过 \(18m^2/n^2\)），因此 LCQ、LCR 及相关队列的更新成本也非常低，不会成为算法瓶颈。

---